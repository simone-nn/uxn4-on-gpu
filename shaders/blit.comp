#version 450
//
// Created by Andrei Ghita
// Based on the UXN emulator from https://wiki.xxiivv.com/site/uxn.html
//

// how many instructions should the VM do before halting
// think of this as a soft timeout
// uncomment this line if you are getting VK_TIMEOUT errors
//#define MAX_STEPS 100000


// ----------------------  UXN Emu -----------------------------

layout(std430, set = 0, binding = 0) buffer Shared_UXN_Buffer {
    uint pc;
    uint dev[256];  // device data
    uint flags;
    uint halt;
} shared_uxn;

layout(std430, set = 0, binding = 1) buffer Private_UXN_Buffer {
    uint ram[65536];
    uint wst[256];  // working stack
    uint pWst;
    uint rst[256];  // return stack
    uint pRst;
} uxn;

layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
// layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in; // single threaded temporarily

/* VM Registry State */
struct State {
    uint a, b, c;
    uvec2 x, y, z;
};

// Invocation-local variables
uint local_wst[256];
uint local_rst[256];
uint local_pWst = 0;
uint local_pRst;
uint local_pc;
uint local_dev[16];
bool lastWorker;

/* Unroll */
#define OPC(opc, init, body) \
	case 0x00|opc: {const int _2=0,_r=0;init body;} break;\
	case 0x20|opc: {const int _2=1,_r=0;init body;} break;\
	case 0x40|opc: {const int _2=0,_r=1;init body;} break;\
	case 0x60|opc: {const int _2=1,_r=1;init body;} break;\
	case 0x80|opc: {const int _2=0,_r=0;uint k=uxn.pWst;init uxn.pWst=k;body;} break;\
	case 0xa0|opc: {const int _2=1,_r=0;uint k=uxn.pWst;init uxn.pWst=k;body;} break;\
	case 0xc0|opc: {const int _2=0,_r=1;uint k=uxn.pRst;init uxn.pRst=k;body;} break;\
	case 0xe0|opc: {const int _2=1,_r=1;uint k=uxn.pRst;init uxn.pRst=k;body;} break;\

/* Local OPC */
#define OPC_LOCAL(opc, init, body) \
	case 0x00|opc: {const int _2=0,_r=0;init body;} break;\
	case 0x20|opc: {const int _2=1,_r=0;init body;} break;\
	case 0x40|opc: {const int _2=0,_r=1;init body;} break;\
	case 0x60|opc: {const int _2=1,_r=1;init body;} break;\
	case 0x80|opc: {const int _2=0,_r=0;uint k=local_pWst;init local_pWst=k;body;} break;\
	case 0xa0|opc: {const int _2=1,_r=0;uint k=local_pWst;init local_pWst=k;body;} break;\
	case 0xc0|opc: {const int _2=0,_r=1;uint k=local_pRst;init local_pRst=k;body;} break;\
	case 0xe0|opc: {const int _2=1,_r=1;uint k=local_pRst;init local_pRst=k;body;} break;\

// ---------------------- Blit -----------------------------

layout(set = 1, binding = 2, rgba8) uniform image2D background;
layout(set = 1, binding = 3, rgba8) uniform image2D foreground;

shared bool workerFlag;

// System Device Addresses
#define SYS_R 0x08
#define SYS_G 0x0a
#define SYS_B 0x0c
// Screen Device Addresses
#define SCREEN_VEC      0x20
#define SCREEN_WIDTH    0x22
#define SCREEN_HEIGHT   0x24
#define SCREEN_AUTO     0x26
#define SCREEN_X        0x28
#define SCREEN_Y        0x2a
#define SCREEN_ADDR     0x2c
#define SCREEN_PIXEL    0x2e
#define SCREEN_SPRITE   0x2f
// Paralleliser Device Addresses
#define PARA_CTRL       0xd0
#define PARA_LOW        0xd1
#define PARA_UP         0xd3
#define PARA_COMM       0xd5
// Flags
#define DRAW_PIXEL_FLAG  0x100
#define DRAW_SPRITE_FLAG 0x200
// Pixel Modes
#define PIXEL_BACKGROUND_MASK 0x00
#define PIXEL_FOREGROUND_MASK 0x40
// Blending Chart
const uint blending[4][16] = uint[4][16](
    uint[16](0, 0, 0, 0, 1, 0, 1, 1, 2, 2, 0, 2, 3, 3, 3, 0),
    uint[16](0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3),
    uint[16](1, 2, 3, 1, 1, 2, 3, 1, 1, 2, 3, 1, 1, 2, 3, 1),
    uint[16](2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2)
);

// ---------------------- Blit Funcs -----------------------------

uint get_byte(uint addr) {
    return shared_uxn.dev[addr];
}

uint get_short(uint addr) {
    return (shared_uxn.dev[addr] << 8) | shared_uxn.dev[addr + 1];
}

void to_short(uint v, uint addr) {
    shared_uxn.dev[addr]   = (v >> 8) & 0xff;
    shared_uxn.dev[addr+1] =  v       & 0xff;
}

bool mask(uint x, uint mask) {
    return (x & mask) == mask;
}

vec4 get_colour(uint colour_i) {
    if (colour_i < 4) {
        uint shift = (3 - colour_i) * 4;
        uint r = (get_short(SYS_R) >> shift) & 0xF;
        uint g = (get_short(SYS_G) >> shift) & 0xF;
        uint b = (get_short(SYS_B) >> shift) & 0xF;
        uvec3 sys_colours = uvec3(r, g, b);
        return vec4(sys_colours.xyz / 15.0, 1.0); // max 0xF
    }
    return vec4(1.0, 0.0, 0.0, 1.0);
}

vec4 colour_2bpp(uint sprite_low, uvec2 offset, ivec2 auto_xy, int auto_i) {
    // ---------------------- 2 bpp --------------------------------
    uint addr = get_short(SCREEN_ADDR) + offset.y + (auto_xy.y * auto_i * 8);
    uint ch1 = uxn.ram[addr];
    uint ch2 = uxn.ram[addr + 8];
    uint pixel_value = ((ch1 >> (7 - offset.x)) & 1) | (((ch2 >> (7 - offset.x)) & 1) << 1);
    
    uint opaque = sprite_low % 5;
    uint palette_index = blending[pixel_value][sprite_low];
    
    if (opaque != 0 || pixel_value != 0) {
        return get_colour(palette_index);
    }
    return vec4(0, 0, 0, 0);
}

vec4 colour_1bpp(uint sprite_low, uvec2 offset, ivec2 auto_xy, int auto_i) {
    // ---------------------- 1 bpp --------------------------------
    uint addr = get_short(SCREEN_ADDR) + offset.y + (auto_xy.y * auto_i * 8);
    uint row = uxn.ram[addr];
    uint pixel_bit = (row >> (7 - offset.x)) & 0x1;
    
    uint opaque = sprite_low % 5; // for 0, 5, a, f, off bits are left as is
    uint palette_index = blending[pixel_bit][sprite_low];
    
    if (opaque != 0 || pixel_bit != 0) {
        return get_colour(palette_index);
    }
    return vec4(0, 0, 0, 0);
}

void drawPixel() {
    uint pixel = get_byte(SCREEN_PIXEL);
    
    // Fill mode (bit 7 = 0x80)
    // if ((pixel & 0x80) == 0 && (offset == uvec2(0, 0))) {
    if ((pixel & 0x80) == 0 ) {
        // ---------------------- pixel --------------------------------
        // coordinates
        uint x = get_short(SCREEN_X);
        uint y = get_short(SCREEN_Y);
        ivec2 coords = ivec2(x, y);

        // colour
        uint pixel = get_byte(SCREEN_PIXEL);
        vec4 colour = get_colour(pixel & 0x0f);

        // editing the image
        if (pixel / 0x10 == 0x0) {
            imageStore(background, coords, colour);
        }
        if (pixel / 0x10 == 0x4) {
            imageStore(foreground, coords, colour);
        }
    } else {
        // ---------------------- fill mode -----------------------------
        bool layer_fg = (pixel & 0x40) != 0;
        vec4 colour = get_colour(pixel & 0x03);
        
        // Calculate fill region based on bits 4 (x range) and 5 (y range)
        uint x = get_short(SCREEN_X);
        uint y = get_short(SCREEN_Y);
        uint width = get_short(SCREEN_WIDTH);
        uint height = get_short(SCREEN_HEIGHT);
        
        uint x1 = ((pixel & 0x10) != 0) ? 0 : x;
        uint x2 = ((pixel & 0x10) != 0) ? x : width;
        uint y1 = ((pixel & 0x20) != 0) ? 0 : y;
        uint y2 = ((pixel & 0x20) != 0) ? y : height;

        // multi-thread version
        // uvec2 thread_coord = gl_GlobalInvocationID.xy; // (0-7, 0-7)

        // // Each thread handles every 8th pixel in x and y
        // for (uint py = y1 + thread_coord.y; py < y2; py += 8) {
        //     for (uint px = x1 + thread_coord.x; px < x2; px += 8) {
        //         if (layer_fg) {
        //             imageStore(foreground, ivec2(px, py), colour);
        //         } else {
        //             imageStore(background, ivec2(px, py), colour);
        //         }
        //     }
        // }

        // single thread version
        for (uint py = y1; py < y2; py++) {
            for (uint px = x1; px < x2; px++) {
                if (layer_fg) {
                    imageStore(foreground, ivec2(px, py), colour);
                } else {
                    imageStore(background, ivec2(px, py), colour);
                }
            }
        }
    }
}
void drawSprite() {
    uint sprite = get_byte(SCREEN_SPRITE);
    uint sprite_low = sprite & 0xf;
    vec4 v_colour;

    // flipped, modes and layer
    bool mode_is_2bpp = ((sprite >> 7) & 1) != 0;
    bool layer_is_foreground = ((sprite >> 6) & 1) != 0;

    // coordinates
    uint x = get_short(SCREEN_X);
    uint y = get_short(SCREEN_Y);
    bool y_flipped = ((sprite >> 5) & 1) == 1;
    bool x_flipped = ((sprite >> 4) & 1) == 1;
    ivec2 coords = ivec2(x, y);

    // auto
    uint auto_byte = get_byte(SCREEN_AUTO);
    uint auto_length = ((auto_byte >> 4) & 0xf);
    ivec2 auto_xy = ivec2(auto_byte & 1, (auto_byte >> 1) & 1);
    auto_xy.x = x_flipped ? (-auto_xy.x) : auto_xy.x;
    auto_xy.y = y_flipped ? (-auto_xy.y) : auto_xy.y;
    bool auto_addr = ((auto_byte >> 2) & 1) != 0;

    // multi-thread version
    // for (int i = 0; i < auto_length; i ++) {
    //     ivec2 o = (i * 8) * auto_xy.yx;

    //     // choosing the bpp mode
    //     vec4 v_colour = mode_is_2bpp ? colour_2bpp(sprite_low, offset, auto_xy, auto_addr ? i : 0)
    //                                  : colour_1bpp(sprite_low, offset, auto_xy, auto_addr ? i : 0);

    //     // if(v_colour == vec4(0, 0, 0, 0)) { continue; }

    //     if (layer_is_foreground) {
    //         imageStore(foreground, coords + o, v_colour);
    //     } else {
    //         imageStore(background, coords + o, v_colour);
    //     }
    // }

    // single thread version
    // drawing
    for (int i = 0; i < auto_length+1; i++) {
        ivec2 sprite_base = coords + (i * 8) * auto_xy.yx;
        
        // Loop through all 8x8 pixels of this sprite
        for (int py = 0; py < 8; py++) {
            for (int px = 0; px < 8; px++) {
                ivec2 pixel_offset = ivec2(px, py);
                
                vec4 v_colour = mode_is_2bpp 
                    ? colour_2bpp(sprite_low, pixel_offset, auto_xy, auto_addr ? i : 0)
                    : colour_1bpp(sprite_low, pixel_offset, auto_xy, auto_addr ? i : 0);
                
                ivec2 write_pos = sprite_base + ivec2(
                    x_flipped ? (7 - px) : px,
                    y_flipped ? (7 - py) : py
                );
                
                if (layer_is_foreground) {
                    imageStore(foreground, write_pos, v_colour);
                } else {
                    imageStore(background, write_pos, v_colour);
                }
            }
        }

        to_short(x + auto_xy.x * 8, SCREEN_X);
        to_short(y + auto_xy.y * 8, SCREEN_Y);
        uint addr = get_short(SCREEN_ADDR);
        uint s = auto_addr ? (mode_is_2bpp ? 16 : 8) : 0;
        to_short(addr + s * auto_length, SCREEN_ADDR);
    }
}


// ---------------------- Blit Funcs (Local) -----------------------------

uint get_byte_local(uint addr) {
    return local_dev[addr & 0x0f];
}

uint get_short_local(uint addr) {
    uint index = addr & 0x0f;
    return (local_dev[index] << 8) | local_dev[index + 1];
}

void to_short_local(uint v, uint addr) {
    uint index = addr & 0x0f;
    local_dev[index]     = (v >> 8) & 0xff;
    local_dev[index + 1] =  v       & 0xff;
}

vec4 colour_2bpp_local(uint sprite_low, uvec2 offset, ivec2 auto_xy, int auto_i) {
    uint addr = get_short_local(SCREEN_ADDR) + offset.y + (auto_xy.y * auto_i * 8);
    uint ch1 = uxn.ram[addr];
    uint ch2 = uxn.ram[addr + 8];
    uint pixel_value = ((ch1 >> (7 - offset.x)) & 1) | (((ch2 >> (7 - offset.x)) & 1) << 1);
    
    uint opaque = sprite_low % 5;
    uint palette_index = blending[pixel_value][sprite_low];
    
    if (opaque != 0 || pixel_value != 0) {
        return get_colour(palette_index);
    }
    return vec4(0, 0, 0, 0);
}

vec4 colour_1bpp_local(uint sprite_low, uvec2 offset, ivec2 auto_xy, int auto_i) {
    uint addr = get_short_local(SCREEN_ADDR) + offset.y + (auto_xy.y * auto_i * 8);
    uint row = uxn.ram[addr];
    uint pixel_bit = (row >> (7 - offset.x)) & 0x1;
    
    uint opaque = sprite_low % 5;
    uint palette_index = blending[pixel_bit][sprite_low];
    
    if (opaque != 0 || pixel_bit != 0) {
        return get_colour(palette_index);
    }
    return vec4(0, 0, 0, 0);
}

void drawPixel_local() {
    uint pixel = get_byte_local(SCREEN_PIXEL);
    
    if ((pixel & 0x80) == 0) {
        uint x = get_short_local(SCREEN_X);
        uint y = get_short_local(SCREEN_Y);
        ivec2 coords = ivec2(x, y);

        vec4 colour = get_colour(pixel & 0x0f);

        if (pixel / 0x10 == 0x0) {
            imageStore(background, coords, colour);
        }
        if (pixel / 0x10 == 0x4) {
            imageStore(foreground, coords, colour);
        }
    } else {
        bool layer_fg = (pixel & 0x40) != 0;
        vec4 colour = get_colour(pixel & 0x03);
        
        uint x = get_short_local(SCREEN_X);
        uint y = get_short_local(SCREEN_Y);
        uint width = get_short_local(SCREEN_WIDTH);
        uint height = get_short_local(SCREEN_HEIGHT);
        
        uint x1 = ((pixel & 0x10) != 0) ? 0 : x;
        uint x2 = ((pixel & 0x10) != 0) ? x : width;
        uint y1 = ((pixel & 0x20) != 0) ? 0 : y;
        uint y2 = ((pixel & 0x20) != 0) ? y : height;

        for (uint py = y1; py < y2; py++) {
            for (uint px = x1; px < x2; px++) {
                if (layer_fg) {
                    imageStore(foreground, ivec2(px, py), colour);
                } else {
                    imageStore(background, ivec2(px, py), colour);
                }
            }
        }
    }
}

void drawSprite_local() {
    uint sprite = get_byte_local(SCREEN_SPRITE);
    uint sprite_low = sprite & 0xf;

    bool mode_is_2bpp = ((sprite >> 7) & 1) != 0;
    bool layer_is_foreground = ((sprite >> 6) & 1) != 0;

    uint x = get_short_local(SCREEN_X);
    uint y = get_short_local(SCREEN_Y);
    bool y_flipped = ((sprite >> 5) & 1) == 1;
    bool x_flipped = ((sprite >> 4) & 1) == 1;
    ivec2 coords = ivec2(x, y);

    uint auto_byte = get_byte_local(SCREEN_AUTO);
    uint auto_length = ((auto_byte >> 4) & 0xf);
    ivec2 auto_xy = ivec2(auto_byte & 1, (auto_byte >> 1) & 1);
    auto_xy.x = x_flipped ? (-auto_xy.x) : auto_xy.x;
    auto_xy.y = y_flipped ? (-auto_xy.y) : auto_xy.y;
    bool auto_addr = ((auto_byte >> 2) & 1) != 0;

    for (int i = 0; i < auto_length + 1; i++) {
        ivec2 sprite_base = coords + (i * 8) * auto_xy.yx;
        
        for (int py = 0; py < 8; py++) {
            for (int px = 0; px < 8; px++) {
                ivec2 pixel_offset = ivec2(px, py);
                
                vec4 v_colour = mode_is_2bpp 
                    ? colour_2bpp_local(sprite_low, pixel_offset, auto_xy, auto_addr ? i : 0)
                    : colour_1bpp_local(sprite_low, pixel_offset, auto_xy, auto_addr ? i : 0);
                
                ivec2 write_pos = sprite_base + ivec2(
                    x_flipped ? (7 - px) : px,
                    y_flipped ? (7 - py) : py
                );
                
                if (layer_is_foreground) {
                    imageStore(foreground, write_pos, v_colour);
                } else {
                    imageStore(background, write_pos, v_colour);
                }
            }
        }

        to_short_local(x + auto_xy.x * 8, SCREEN_X);
        to_short_local(y + auto_xy.y * 8, SCREEN_Y);
        uint addr = get_short_local(SCREEN_ADDR);
        uint s = auto_addr ? (mode_is_2bpp ? 16 : 8) : 0;
        to_short_local(addr + s * auto_length, SCREEN_ADDR);
    }
}

// ---------------------- Parallel Funcs -----------------------------

void parallel_loop(){
    uint ctr = get_byte(PARA_CTRL);
    if (ctr == 1) workerFlag = true;
}

uint end_parallel_loop(uint addr, uvec2 v, int _2){
    if (lastWorker) {
        shared_uxn.pc = local_pc;
        shared_uxn.dev[addr] = v.x; // Para Crtl
        if (_2 != 0) {
            shared_uxn.dev[addr + 1] = v.y;
            }
        for (uint i = 0; i < 16; i++) {
            shared_uxn.dev[0x20 + i] = local_dev[i];
        }
    }
    return 2;
}

// ---------------------- UXN Funcs -----------------------------

/* Microcode */
void push_wst(uint i) { uxn.wst[uxn.pWst] = i; uxn.pWst++; }

void push_rst(uint i) { uxn.rst[uxn.pRst] = i; uxn.pRst++; }

uint pop_wst() { uxn.pWst--; return uxn.wst[uxn.pWst]; }

uint pop_rst() { uxn.pRst--; return uxn.rst[uxn.pRst]; }

void PUr(uint i, int _r) {
    if(_r != 0) {
        push_wst(i);
    } else {
        push_rst(i);
    }
}

uint PO1(int _r) {
    return (_r != 0) ? pop_rst() : pop_wst();
}

uint PO2(int _r) {
    return (_r != 0) ? pop_rst() | pop_rst() << 8 : pop_wst() | pop_wst() << 8;
}

uint POx(int _r, int _2) {
    return (_2 != 0) ? PO2(_r) : PO1(_r);
}

void PU1(uint i, int _r) {
    if(_r != 0) {
        push_rst(i);
    } else {
        push_wst(i);
    }
}

void PUx(inout State s, uint i, int _r, int _2) {
    if (_2 != 0) {
        s.c = i & 0xffff;
        PU1(s.c >> 8, _r);
        PU1(s.c, _r);
    } else {
        PU1(i % 0xff, _r);
    }
}

void PUT(uvec2 i, int _r, int _2) {
    PU1(i.x, _r);
    if (_2 != 0) {
        PU1(i.y, _r);
    }
}

void POK(uint i, uvec2 j, uint m, int _r, int _2) {
    uxn.ram[i] = j.x;
    if(_2 != 0) {
        uxn.ram[(i + 1) & m] = j.y;
    }
}

void PEK(inout uvec2 o, uint i, uint m, int _r, int _2) {
    o.x = uxn.ram[i];
    if (_2 != 0) {
        o.y = uxn.ram[(i + 1) & m];
    }
    PUT(o,_r,_2);
}

void GET(inout uvec2 v, int _r, int _2) {
    if(_2 != 0) {
        v.y = PO1(_r);
        v.x = PO1(_r);
    } else {
        v.x = PO1(_r);
    }
}

void JMI(inout State s) {
    s.a = ((uxn.ram[shared_uxn.pc] & 0xff) << 8) | (uxn.ram[shared_uxn.pc + 1] & 0xff);
    shared_uxn.pc += 2 + s.a; // 2 comes from the size of the jumpto label
    shared_uxn.pc = shared_uxn.pc % 0x10000; // ensure 16bit overflow behaviour
}

void JMP(uint i, int _2) {
    if (_2 == 0) {
        // byte mode
        shared_uxn.pc += (i & 0x7f) - (i & 0x80);
    } else {
        // short mode
        shared_uxn.pc = i & 0xffff;
    }
}

void REM(int _r, int _2) {
    if(_r != 0) {
        uxn.pRst -= 1 + _2;
    } else {
        uxn.pWst -= 1 + _2;
    }
}

/* Devices */
// Flags
#define DEO_FLAG          0x001
#define DEO_CONSOLE_FLAG  0x002
#define DEO_CERROR_FLAG   0x004
#define DEO_SCREENW_FLAG  0x008
#define DEO_SCREENH_FLAG  0x010
#define DEI_CONSOLE_FLAG  0x020
#define DRAW_PIXEL_FLAG   0x100
#define DRAW_SPRITE_FLAG  0x200

// input from device
uvec2 DEI(uint addr, uvec2 o, int _r, int _2) {

    if (addr == 0x12) shared_uxn.flags = DEI_CONSOLE_FLAG;

    o.x = shared_uxn.dev[addr];
    if (_2 != 0) {
        o.y = shared_uxn.dev[addr + 1];
    }
    PUT(o,_r,_2);
    return o;
}

// output to device
uint DEO(uint addr, uvec2 v, int _2) {

    // cannot resize screen
    // if (addr == 0x22) return 0;
    // if (addr == 0x24) return 0;

    // updated support for screen resize

    shared_uxn.dev[addr] = v.x;
    if (_2 != 0) {
        shared_uxn.dev[addr + 1] = v.y;
    }

    shared_uxn.flags |= DEO_FLAG;
    if (addr == 0x22) shared_uxn.flags |= DEO_SCREENW_FLAG;
    if (addr == 0x24) shared_uxn.flags |= DEO_SCREENH_FLAG;
    if (addr == 0x2e) drawPixel();
    if (addr == 0x2f) drawSprite();
    if (addr == 0x18) shared_uxn.flags |= DEO_CONSOLE_FLAG;
    if (addr == 0x19) shared_uxn.flags |= DEO_CERROR_FLAG;
    if (addr == 0xd0) parallel_loop();

    // no need to halt in a lot of cases, i.e. when writting to Screen/X
    uint halt = 2 + _2; // halt code for DEO/DEO2

    //todo there might be more ports that can be optimised like this
    if (addr == 0x26 || addr == 0x28 || addr == 0x2a || addr == 0x2c || addr == 0x2e || addr == 0x2f || (addr & 0xf0) == 0xd0){
        halt = 0; // no need to halt
    }

    return halt; // halt code for DEO
}

uint uxn_eval(State state) {
    // check for shutdown
	if((shared_uxn.pc == 0) || (shared_uxn.dev[0x0f] != 0)) return 5;
	// select instruction
	switch(uxn.ram[shared_uxn.pc++] & 0xff) {
    /* BRK */ case 0x00: return 1;
    /* JCI */ case 0x20:
                if(uxn.wst[--uxn.pWst] != 0) { JMI(state); }
                else { shared_uxn.pc += 2; }
                break;
    /* JMI */ case 0x40: JMI(state); break;
    /* JSI */ case 0x60:
                state.c = shared_uxn.pc + 2;
                push_rst((state.c >> 8) & 0xff);
                push_rst(state.c & 0xff);
                JMI(state); break;
    /* LI2 */ case 0xa0: push_wst(uxn.ram[shared_uxn.pc++]); /* fall-through */
    /* LIT */ case 0x80: push_wst(uxn.ram[shared_uxn.pc++]); break;
    /* L2r */ case 0xe0: push_rst(uxn.ram[shared_uxn.pc++]); /* fall-through */
    /* LIr */ case 0xc0: push_rst(uxn.ram[shared_uxn.pc++]); break;
    /* INC */ OPC(0x01, state.a = POx(_r, _2);, PUx(state, state.a + 1, _r, _2);)
    /* POP */ OPC(0x02, REM(_r, _2);, {})
    /* NIP */ OPC(0x03,
                  GET(state.x, _r, _2); REM(_r, _2); ,
                  PUT(state.x, _r, _2); )
    /* SWP */ OPC(0x04,
                  GET(state.x, _r, _2); GET(state.y, _r, _2); ,
                  PUT(state.x, _r, _2); PUT(state.y, _r, _2); )
    /* ROT */ OPC(0x05,
                  GET(state.x,_r,_2);
                  GET(state.y,_r,_2);
                  GET(state.z,_r,_2); ,
                  PUT(state.y,_r,_2);
                  PUT(state.x,_r,_2);
                  PUT(state.z,_r,_2); )
    /* DUP */ OPC(0x06,
                  GET(state.x,_r,_2); ,
                  PUT(state.x,_r,_2);
                  PUT(state.x,_r,_2); )
    /* OVR */ OPC(0x07,
                  GET(state.x,_r,_2); GET(state.y,_r,_2); ,
                  PUT(state.y,_r,_2); PUT(state.x,_r,_2); PUT(state.y,_r,_2); )
    /* EQU */ OPC(0x08,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  if (state.b == state.a) { PU1(1,_r); }
                  else { PU1(0,_r); })
    /* NEQ */ OPC(0x09,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  if (state.b != state.a) { PU1(1,_r); }
                  else { PU1(0,_r); })
    /* GTH */ OPC(0x0a,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  if (state.b > state.a) { PU1(1,_r); }
                  else { PU1(0,_r); })
    /* LTH */ OPC(0x0b,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  if (state.b < state.a) { PU1(1,_r); }
                  else { PU1(0,_r); })
    /* JMP */ OPC(0x0c,
                  state.a = POx(_r,_2); ,
                  JMP(state.a, _2); )
    /* JCN */ OPC(0x0d,
                  state.a = POx(_r,_2); state.b = PO1(_r); ,
                  if(state.b != 0) { JMP(state.a, _2); })
    /* JSR */ OPC(0x0e,
                  state.a = POx(_r,_2); ,
                  PUr(shared_uxn.pc >> 8,_r); PUr(shared_uxn.pc,_r); JMP(state.a, _2); )
    /* STH */ OPC(0x0f,
                  GET(state.x,_r,_2); ,
                  PUr(state.x.x,_r);
                  if(_2 != 0) { PUr(state.x.y,_r); })
    /* LDZ */ OPC(0x10,
                  state.a = PO1(_r); ,
                  PEK(state.x, state.a, 0xff, _r, _2); )
    /* STZ */ OPC(0x11,
                  state.a = PO1(_r); GET(state.y,_r,_2); ,
                  POK(state.a, state.y, 0xff, _r, _2); )
    /* LDR */ OPC(0x12,
                  state.a = PO1(_r); ,
                  PEK(state.x, shared_uxn.pc+ (state.a & 0x7f) - (state.a & 0x80), 0xffff, _r,_2); )
    /* STR */ OPC(0x13,
                  state.a = PO1(_r); GET(state.y,_r,_2); ,
                  POK(shared_uxn.pc+ (state.a & 0x7f) - (state.a & 0x80), state.y, 0xffff, _r,_2); )
    /* LDA */ OPC(0x14,
                  state.a = PO2(_r); ,
                  PEK(state.x, state.a, 0xffff, _r,_2); )
    /* STA */ OPC(0x15,
                  state.a = PO2(_r); GET(state.y,_r,_2); ,
                  POK(state.a, state.y, 0xffff, _r,_2); )
    /* DEI */ OPC(0x16,
                  state.a = PO1(_r); ,
                  state.x = DEI(state.a, state.x, _r,_2); )
    /* DEO */ OPC(0x17,
                  state.a = PO1(_r); GET(state.y,_r,_2); ,
                  return DEO(state.a, state.y, _2); ) // DEO: halt code 2 | DEO2: halt code 3
    /* ADD */ OPC(0x18,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  PUx(state, state.b + state.a, _r,_2); )
    /* SUB */ OPC(0x19,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  PUx(state, state.b - state.a, _r,_2); )
    /* MUL */ OPC(0x1a,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  PUx(state, state.b * state.a, _r,_2); )
    /* DIV */ OPC(0x1b,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  if (state.a == 0) { PUx(state, 0, _r,_2); }
                  else { PUx(state, state.b / state.a, _r,_2); } )
    /* AND */ OPC(0x1c,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  PUx(state, state.a & state.b, _r,_2); )
    /* ORA */ OPC(0x1d,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  PUx(state, state.a | state.b, _r,_2); )
    /* EOR */ OPC(0x1e,
                  state.a = POx(_r,_2); state.b = POx(_r,_2); ,
                  PUx(state, state.a ^ state.b, _r,_2); )
    /* SFT */ OPC(0x1f,
                  state.a = PO1(_r); state.b = POx(_r,_2); ,
                  PUx(state, state.b >> (state.a & 0xf) << (state.a >> 4), _r,_2); )
              default: return 4; // Crash
	}
	return 0; // Continue execution
}


// ---------------------- UXN Funcs (LOCAL) -----------------------------

/* Microcode */
void push_wst_local(uint i) { local_wst[local_pWst] = i; local_pWst++; }

void push_rst_local(uint i) { local_rst[local_pRst] = i; local_pRst++; }

uint pop_wst_local() { local_pWst--; return local_wst[local_pWst]; }

uint pop_rst_local() { local_pRst--; return local_rst[local_pRst]; }

void PUr_local(uint i, int _r) {
    if(_r != 0) {
        push_wst_local(i);
    } else {
        push_rst_local(i);
    }
}

uint PO1_local(int _r) {
    return (_r != 0) ? pop_rst_local() : pop_wst_local();
}

uint PO2_local(int _r) {
    return (_r != 0) ? pop_rst_local() | pop_rst_local() << 8 : pop_wst_local() | pop_wst_local() << 8;
}

uint POx_local(int _r, int _2) {
    return (_2 != 0) ? PO2_local(_r) : PO1_local(_r);
}

void PU1_local(uint i, int _r) {
    if(_r != 0) {
        push_rst_local(i);
    } else {
        push_wst_local(i);
    }
}

void PUx_local(inout State s, uint i, int _r, int _2) {
    if (_2 != 0) {
        s.c = i & 0xffff;
        PU1_local(s.c >> 8, _r);
        PU1_local(s.c, _r);
    } else {
        PU1_local(i % 0xff, _r);
    }
}

void PUT_local(uvec2 i, int _r, int _2) {
    PU1_local(i.x, _r);
    if (_2 != 0) {
        PU1_local(i.y, _r);
    }
}

void POK_local(uint i, uvec2 j, uint m, int _r, int _2) {
    uxn.ram[i] = j.x;
    if(_2 != 0) {
        uxn.ram[(i + 1) & m] = j.y;
    }
}

void PEK_local(inout uvec2 o, uint i, uint m, int _r, int _2) {
    o.x = uxn.ram[i];
    if (_2 != 0) {
        o.y = uxn.ram[(i + 1) & m];
    }
    PUT_local(o,_r,_2);
}

void GET_local(inout uvec2 v, int _r, int _2) {
    if(_2 != 0) {
        v.y = PO1_local(_r);
        v.x = PO1_local(_r);
    } else {
        v.x = PO1_local(_r);
    }
}

void JMI_local(inout State s) {
    s.a = ((uxn.ram[local_pc] & 0xff) << 8) | (uxn.ram[local_pc + 1] & 0xff);
    local_pc += 2 + s.a;
    local_pc = local_pc % 0x10000;
}

void JMP_local(uint i, int _2) {
    if (_2 == 0) {
        local_pc += (i & 0x7f) - (i & 0x80);
    } else {
        local_pc = i & 0xffff;
    }
}

void REM_local(int _r, int _2) {
    if(_r != 0) {
        local_pRst -= 1 + _2;
    } else {
        local_pWst -= 1 + _2;
    }
}

/* Devices */
uvec2 DEI_local(uint addr, uvec2 o, int _r, int _2) {
    // Workers use local device page for screen (0x20-0x2f)
    if (addr >= 0x20 && addr < 0x30) {
        o.x = local_dev[addr - 0x20];
        if (_2 != 0) {
            o.y = local_dev[addr - 0x20 + 1];
        }
    } else {
        o.x = shared_uxn.dev[addr];
        if (_2 != 0) {
            o.y = shared_uxn.dev[addr + 1];
        }
    }
    PUT_local(o,_r,_2);
    return o;
}

uint DEO_local(uint addr, uvec2 v, int _2) {
    // Parallel device check
    if (addr == 0xd0) {
        return end_parallel_loop(addr, v, _2);
    }
    
    // Screen ports
    if ((addr & 0xf0) == 0x20) {
        uint index = addr & 0x0f;
        local_dev[index] = v.x;
        if (_2 != 0) {
            local_dev[index + 1] = v.y;
        }
        
        if (addr == 0x2e) drawPixel_local();
        if (addr == 0x2f) drawSprite_local();
    }
    
    return 0;  // Workers don't halt on screen DEO
}

uint uxn_eval_local(State state) {
    if(local_pc > 0xffff) return 5;
    switch(uxn.ram[local_pc++] & 0xff) {
    case 0x00: return 1;
    case 0x20:
                if(local_wst[--local_pWst] != 0) { JMI_local(state); }
                else { local_pc += 2; }
                break;
    case 0x40: JMI_local(state); break;
    case 0x60:
                state.c = local_pc + 2;
                push_rst_local((state.c >> 8) & 0xff);
                push_rst_local(state.c & 0xff);
                JMI_local(state); break;
    case 0xa0: push_wst_local(uxn.ram[local_pc++]);
    case 0x80: push_wst_local(uxn.ram[local_pc++]); break;
    case 0xe0: push_rst_local(uxn.ram[local_pc++]);
    case 0xc0: push_rst_local(uxn.ram[local_pc++]); break;
    OPC_LOCAL(0x01, state.a = POx_local(_r, _2);, PUx_local(state, state.a + 1, _r, _2);)
    OPC_LOCAL(0x02, REM_local(_r, _2);, {})
    OPC_LOCAL(0x03,
                  GET_local(state.x, _r, _2); REM_local(_r, _2); ,
                  PUT_local(state.x, _r, _2); )
    OPC_LOCAL(0x04,
                  GET_local(state.x, _r, _2); GET_local(state.y, _r, _2); ,
                  PUT_local(state.x, _r, _2); PUT_local(state.y, _r, _2); )
    OPC_LOCAL(0x05,
                  GET_local(state.x,_r,_2);
                  GET_local(state.y,_r,_2);
                  GET_local(state.z,_r,_2); ,
                  PUT_local(state.y,_r,_2);
                  PUT_local(state.x,_r,_2);
                  PUT_local(state.z,_r,_2); )
    OPC_LOCAL(0x06,
                  GET_local(state.x,_r,_2); ,
                  PUT_local(state.x,_r,_2);
                  PUT_local(state.x,_r,_2); )
    OPC_LOCAL(0x07,
                  GET_local(state.x,_r,_2); GET_local(state.y,_r,_2); ,
                  PUT_local(state.y,_r,_2); PUT_local(state.x,_r,_2); PUT_local(state.y,_r,_2); )
    OPC_LOCAL(0x08,
                  state.a = POx_local(_r,_2); state.b = POx_local(_r,_2); ,
                  if (state.b == state.a) { PU1_local(1,_r); }
                  else { PU1_local(0,_r); })
    OPC_LOCAL(0x09,
                  state.a = POx_local(_r,_2); state.b = POx_local(_r,_2); ,
                  if (state.b != state.a) { PU1_local(1,_r); }
                  else { PU1_local(0,_r); })
    OPC_LOCAL(0x0a,
                  state.a = POx_local(_r,_2); state.b = POx_local(_r,_2); ,
                  if (state.b > state.a) { PU1_local(1,_r); }
                  else { PU1_local(0,_r); })
    OPC_LOCAL(0x0b,
                  state.a = POx_local(_r,_2); state.b = POx_local(_r,_2); ,
                  if (state.b < state.a) { PU1_local(1,_r); }
                  else { PU1_local(0,_r); })
    OPC_LOCAL(0x0c,
                  state.a = POx_local(_r,_2); ,
                  JMP_local(state.a, _2); )
    OPC_LOCAL(0x0d,
                  state.a = POx_local(_r,_2); state.b = PO1_local(_r); ,
                  if(state.b != 0) { JMP_local(state.a, _2); })
    OPC_LOCAL(0x0e,
                  state.a = POx_local(_r,_2); ,
                  PUr_local(local_pc >> 8,_r); PUr_local(local_pc,_r); JMP_local(state.a, _2); )
    OPC_LOCAL(0x0f,
                  GET_local(state.x,_r,_2); ,
                  PUr_local(state.x.x,_r);
                  if(_2 != 0) { PUr_local(state.x.y,_r); })
    OPC_LOCAL(0x10,
                  state.a = PO1_local(_r); ,
                  PEK_local(state.x, state.a, 0xff, _r, _2); )
    OPC_LOCAL(0x11,
                  state.a = PO1_local(_r); GET_local(state.y,_r,_2); ,
                  POK_local(state.a, state.y, 0xff, _r, _2); )
    OPC_LOCAL(0x12,
                  state.a = PO1_local(_r); ,
                  PEK_local(state.x, local_pc+ (state.a & 0x7f) - (state.a & 0x80), 0xffff, _r,_2); )
    OPC_LOCAL(0x13,
                  state.a = PO1_local(_r); GET_local(state.y,_r,_2); ,
                  POK_local(local_pc+ (state.a & 0x7f) - (state.a & 0x80), state.y, 0xffff, _r,_2); )
    OPC_LOCAL(0x14,
                  state.a = PO2_local(_r); ,
                  PEK_local(state.x, state.a, 0xffff, _r,_2); )
    OPC_LOCAL(0x15,
                  state.a = PO2_local(_r); GET_local(state.y,_r,_2); ,
                  POK_local(state.a, state.y, 0xffff, _r,_2); )
    OPC_LOCAL(0x16,
                  state.a = PO1_local(_r); ,
                  state.x = DEI_local(state.a, state.x, _r,_2); )
    OPC_LOCAL(0x17,
                  state.a = PO1_local(_r); GET_local(state.y,_r,_2); ,
                  return DEO_local(state.a, state.y, _2); )
    OPC_LOCAL(0x18,
                  state.a = POx_local(_r,_2); state.b = POx_local(_r,_2); ,
                  PUx_local(state, state.b + state.a, _r,_2); )
    OPC_LOCAL(0x19,
                  state.a = POx_local(_r,_2); state.b = POx_local(_r,_2); ,
                  PUx_local(state, state.b - state.a, _r,_2); )
    OPC_LOCAL(0x1a,
                  state.a = POx_local(_r,_2); state.b = POx_local(_r,_2); ,
                  PUx_local(state, state.b * state.a, _r,_2); )
    OPC_LOCAL(0x1b,
                  state.a = POx_local(_r,_2); state.b = POx_local(_r,_2); ,
                  if (state.a == 0) { PUx_local(state, 0, _r,_2); }
                  else { PUx_local(state, state.b / state.a, _r,_2); } )
    OPC_LOCAL(0x1c,
                  state.a = POx_local(_r,_2); state.b = POx_local(_r,_2); ,
                  PUx_local(state, state.a & state.b, _r,_2); )
    OPC_LOCAL(0x1d,
                  state.a = POx_local(_r,_2); state.b = POx_local(_r,_2); ,
                  PUx_local(state, state.a | state.b, _r,_2); )
    OPC_LOCAL(0x1e,
                  state.a = POx_local(_r,_2); state.b = POx_local(_r,_2); ,
                  PUx_local(state, state.a ^ state.b, _r,_2); )
    OPC_LOCAL(0x1f,
                  state.a = PO1_local(_r); state.b = POx_local(_r,_2); ,
                  PUx_local(state, state.b >> (state.a & 0xf) << (state.a >> 4), _r,_2); )
              default: return 4;
	}
	return 0;
}

// ---------------------- Main -----------------------------

void main() {
    uint tid = gl_GlobalInvocationID.x;
    State state = {0, 0, 0, uvec2(0,0), uvec2(0,0), uvec2(0,0)};
    // Main thread
    shared_uxn.flags = 0;
    shared_uxn.halt = 0;

    // Run the next Uxn instruction
    // possible halt codes:
    // 0 - halt not needed; continue evaluation
    // 1 - BRK encountered
    // 2 - DEO halt
    // 3 - DEO2 halt
    // 4 - opcode not recognised
    // 5 - shutdown
    uint steps = 0;
#ifdef MAX_STEPS
    while (shared_uxn.halt == 0 && steps < 1000) {
#else
    while (shared_uxn.halt == 0) {
#endif
    if (tid == 0){ // Main invocation
            workerFlag = false;
            shared_uxn.halt = uxn_eval(state);
            steps++;
    }
    barrier();
    if (tid > 0 && workerFlag == true) { // Worker invocations

        // Calculate interation range, exit if the current invocation is not needed
        uint numWorkers = gl_WorkGroupSize.x - 1;
        uint workerId = tid - 1;
        uint lower = get_short(PARA_LOW);
        uint upper = get_short(PARA_UP);
        uint num_iter = upper - lower;

        if (workerId >= num_iter) continue;

        uint chunkSize = (num_iter + numWorkers - 1) / numWorkers;
        uint start = lower + workerId * chunkSize;
        uint end = min(start + chunkSize, upper);

        if (start >= end) continue;

        // Initialise local variables
        uint work_finished = 0;

        local_pRst = local_pWst = 0;
        lastWorker = false;

        // Clear local stack
        for (int i = 0; i < 256; i++) {
            local_wst[i] = 0;
            local_rst[i] = 0;
        }

        // Copy data from the SSBO
        local_pc = shared_uxn.pc;
        for (uint i = 0; i < 16; i++) {
            local_dev[i] = shared_uxn.dev[0x20 + i];
        }

        // Populate stack
        push_wst_local(end >> 8);
        push_wst_local(end);
        push_wst_local(start >> 8);
        push_wst_local(start);

        if (end == upper) lastWorker = true;

        // Worker local evaluation loop
        while (work_finished == 0) {
            work_finished = uxn_eval_local(state);
        }

    }  
    barrier();  // Signal worker completion
    }
    shared_uxn.dev[0] = uxn.wst[uxn.pWst-1];
}