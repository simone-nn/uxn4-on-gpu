#version 450

layout(std140, set = 0, binding = 0) buffer Shared_UXN_Buffer {
    uint pc;
    uint dev[256];  // device data
    uint flags;
    uint halt;
} shared_uxn;

layout(std140, set = 0, binding = 1) buffer Private_UXN_Buffer {
    uint ram[65536];
    uint wst[256];  // working stack
    uint pWst;
    uint rst[256];  // return stack
    uint pRst;
} uxn;

layout(set = 1, binding = 2, rgba8) uniform image2D background;
layout(set = 1, binding = 3, rgba8) uniform image2D foreground;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// System Device Addresses
#define SYS_R 0x08
#define SYS_G 0x0a
#define SYS_B 0x0c
// Screen Device Addresses
#define SCREEN_VEC      0x20
#define SCREEN_WIDTH    0x22
#define SCREEN_HEIGHT   0x24
#define SCREEN_AUTO     0x26
#define SCREEN_X        0x28
#define SCREEN_Y        0x2a
#define SCREEN_ADDR     0x2c
#define SCREEN_PIXEL    0x2e
#define SCREEN_SPRITE   0x2f
// Flags
#define DRAW_PIXEL_FLAG  0x100
#define DRAW_SPRITE_FLAG 0x200
// Pixel Modes
#define PIXEL_BACKGROUND_MASK 0x00
#define PIXEL_FOREGROUND_MASK 0x40
// Blending Chart
const uint blending[4][16] = uint[4][16](
    uint[16](0, 0, 0, 0, 1, 0, 1, 1, 2, 2, 0, 2, 3, 3, 3, 0),
    uint[16](0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3),
    uint[16](1, 2, 3, 1, 1, 2, 3, 1, 1, 2, 3, 1, 1, 2, 3, 1),
    uint[16](2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2)
);

uint get_byte(uint addr) {
    return shared_uxn.dev[addr];
}

uint get_short(uint addr) {
    return (shared_uxn.dev[addr] << 8) | shared_uxn.dev[addr + 1];
}

void to_short(uint v, uint addr) {
    shared_uxn.dev[addr]   = (v >> 8) & 0xff;
    shared_uxn.dev[addr+1] =  v       & 0xff;
}

bool mask(uint x, uint mask) {
    return (x & mask) == mask;
}

vec4 get_colour(uint colour_i) {
    if (colour_i < 4) {
        uint shift = (3 - colour_i) * 4;
        uint r = (get_short(SYS_R) >> shift) & 0xF;
        uint g = (get_short(SYS_G) >> shift) & 0xF;
        uint b = (get_short(SYS_B) >> shift) & 0xF;
        uvec3 sys_colours = uvec3(r, g, b);
        return vec4(sys_colours.xyz / 15.0, 1.0); // max 0xF
    }
    return vec4(1.0, 0.0, 0.0, 1.0);
}

vec4 colour_2bpp(uint sprite_low, uvec2 offset, ivec2 auto_xy, int auto_i) {
    // ---------------------- 2 bpp --------------------------------
    uint addr = get_short(SCREEN_ADDR) + offset.y + (auto_xy.y * auto_i * 8);
    uint ch1 = uxn.ram[addr];
    uint ch2 = uxn.ram[addr + 8];
    uint pixel_value = ((ch1 >> offset.x) & 1) | (((ch2 >> offset.x) & 1) << 1);
    
    uint opaque = sprite_low % 5;
    uint palette_index = blending[pixel_value][sprite_low];
    
    if (opaque != 0 || pixel_value != 0) {
        return get_colour(palette_index);
    }
    return vec4(0, 0, 0, 0);
}

vec4 colour_1bpp(uint sprite_low, uvec2 offset, ivec2 auto_xy, int auto_i) {
    // ---------------------- 1 bpp --------------------------------
    uint addr = get_short(SCREEN_ADDR) + offset.y + (auto_xy.y * auto_i * 8);
    uint row = uxn.ram[addr];
    uint pixel_bit = (row >> offset.x) & 0x1;
    
    uint opaque = sprite_low % 5; // for 0, 5, a, f, off bits are left as is
    uint palette_index = blending[pixel_bit][sprite_low];
    
    if (opaque != 0 || pixel_bit != 0) {
        return get_colour(palette_index);
    }
    return vec4(0, 0, 0, 0);
}

void main() {
    uvec2 offset = uvec2(gl_GlobalInvocationID);
    // pixel requested
    if (mask(shared_uxn.flags, DRAW_PIXEL_FLAG)) {
        uint pixel = get_byte(SCREEN_PIXEL);

        if ((pixel & 0x80) == 0 && (offset == uvec2(0, 0))) {
            // ---------------------- pixel --------------------------------
            // coordinates
            uint x = get_short(SCREEN_X);
            uint y = get_short(SCREEN_Y);
            ivec2 coords = ivec2(x, y);

            // colour
            uint pixel = get_byte(SCREEN_PIXEL);
            vec4 colour = get_colour(pixel & 0x0f);

            // editing the image
            if (pixel / 0x10 == 0x0) {
                imageStore(background, coords, colour);
            }
            if (pixel / 0x10 == 0x4) {
                imageStore(foreground, coords, colour);
            }
        } else if ((pixel & 0x80) != 0) {
            // ---------------------- fill mode -----------------------------
            // layer & colour
            bool layer_fg = (pixel & 0x40) != 0;
            vec4 colour = get_colour(pixel & 0x03);
            
            // calculate fill region based on screen width and height
            uint x = get_short(SCREEN_X);
            uint y = get_short(SCREEN_Y);
            uint width = get_short(SCREEN_WIDTH);
            uint height = get_short(SCREEN_HEIGHT);
            
            uint x1 = ((pixel & 0x10) != 0) ? 0 : x;
            uint x2 = ((pixel & 0x10) != 0) ? x : width;
            uint y1 = ((pixel & 0x20) != 0) ? 0 : y;
            uint y2 = ((pixel & 0x20) != 0) ? y : height;

            uvec2 thread_coord = offset.xy; // (0-7, 0-7)

            // each thread handles every 8th pixel in x and y
            for (uint py = y1 + thread_coord.y; py < y2; py += 8) {
                for (uint px = x1 + thread_coord.x; px < x2; px += 8) {
                    if (layer_fg) {
                        imageStore(foreground, ivec2(px, py), colour);
                    } else {
                        imageStore(background, ivec2(px, py), colour);
                    }
                }
            }
        }
    }
    // sprite requested
    else if (mask(shared_uxn.flags, DRAW_SPRITE_FLAG)) {
        uint sprite = get_byte(SCREEN_SPRITE);
        uint sprite_low = sprite & 0xf;
        vec4 v_colour;

        // flipped, modes and layer
        bool mode_is_2bpp = ((sprite >> 7) & 1) != 0; // bit 7 for BPP mode
        bool layer_is_foreground = ((sprite >> 6) & 1) != 0; // bit 6 for layer

        // coordinates
        uint x = get_short(SCREEN_X);
        uint y = get_short(SCREEN_Y);
        bool y_flipped = ((sprite >> 5) & 1) == 1; // bit 5 for flip-y
        bool x_flipped = ((sprite >> 4) & 1) == 1; // bit 4 for flip-x
        ivec2 coords;

        coords.x = int(x + (x_flipped ? offset.x : (7 - offset.x)));
        coords.y = int(y + (y_flipped ? (7 - offset.y) : offset.y));

        // auto
        uint auto_byte = get_byte(SCREEN_AUTO);
        uint auto_length = ((auto_byte >> 4) & 0xf);
        ivec2 auto_xy = ivec2(auto_byte & 1, (auto_byte >> 1) & 1);
        auto_xy.x = x_flipped ? (-auto_xy.x) : auto_xy.x;
        auto_xy.y = y_flipped ? (-auto_xy.y) : auto_xy.y;
        //if auto addr bit is set, then the addr needs to be incremented like the coords
        bool auto_addr = ((auto_byte >> 2) & 1) != 0;

        // drawing
        for (int i = 0; i < auto_length + 1; i ++) {

            // TODO: fix sprite address increment in multi-thread dispatch

            ivec2 o = (i * 8) * auto_xy.yx;

            // choosing the bpp mode
            vec4 v_colour = mode_is_2bpp ? colour_2bpp(sprite_low, offset, auto_xy, auto_addr ? i : 0)
                                         : colour_1bpp(sprite_low, offset, auto_xy, auto_addr ? i : 0);

            if (layer_is_foreground) {
                imageStore(foreground, coords + o, v_colour);
            } else {
                imageStore(background, coords + o, v_colour);
            }
        }

        // incrementing the ports
        memoryBarrier();
        barrier();
        if (gl_LocalInvocationIndex == 0) {
            to_short(x + auto_xy.x * 8, SCREEN_X);
            to_short(y + auto_xy.y * 8, SCREEN_Y);
            uint addr = get_short(SCREEN_ADDR);
            uint s = auto_addr ? (mode_is_2bpp ? 16 : 8) : 0;
            to_short(addr + s * auto_length, SCREEN_ADDR);
        }
    }
}
